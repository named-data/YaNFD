// Code generated by ndn tlv codegen DO NOT EDIT.
package gen_map

import (
	"encoding/binary"
	"io"
	"strings"

	enc "github.com/pulsejet/ndnd/std/encoding"
)

type StringMapEncoder struct {
	length uint

	Params_valencoder map[string]*struct {
	}
}

type StringMapParsingContext struct {
}

func (encoder *StringMapEncoder) Init(value *StringMap) {
	{
		Params_l := len(value.Params)
		encoder.Params_valencoder = make(map[string]*struct {
		}, Params_l)
		for map_k := range value.Params {
			pseudoEncoder := &struct {
			}{}
			encoder.Params_valencoder[map_k] = pseudoEncoder
			pseudoValue := struct {
				Params_v []byte
			}{
				Params_v: value.Params[map_k],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue

				_ = encoder
				_ = value
			}
		}
	}

	l := uint(0)
	if value.Params != nil {
		for map_k, map_v := range value.Params {
			pseudoEncoder := encoder.Params_valencoder[map_k]
			pseudoValue := struct {
				Params_k string
				Params_v []byte
			}{
				Params_k: map_k,
				Params_v: map_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				l += 1
				switch x := len(value.Params_k); {
				case x <= 0xfc:
					l += 1
				case x <= 0xffff:
					l += 3
				case x <= 0xffffffff:
					l += 5
				default:
					l += 9
				}
				l += uint(len(value.Params_k))
				if value.Params_v != nil {
					l += 1
					switch x := len(value.Params_v); {
					case x <= 0xfc:
						l += 1
					case x <= 0xffff:
						l += 3
					case x <= 0xffffffff:
						l += 5
					default:
						l += 9
					}
					l += uint(len(value.Params_v))
				}
				_ = encoder
				_ = value
			}
		}
	}
	encoder.length = l

}

func (context *StringMapParsingContext) Init() {

}

func (encoder *StringMapEncoder) EncodeInto(value *StringMap, buf []byte) {

	pos := uint(0)

	if value.Params != nil {
		for map_k, map_v := range value.Params {
			pseudoEncoder := encoder.Params_valencoder[map_k]
			pseudoValue := struct {
				Params_k string
				Params_v []byte
			}{
				Params_k: map_k,
				Params_v: map_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				buf[pos] = byte(133)
				pos += 1
				switch x := len(value.Params_k); {
				case x <= 0xfc:
					buf[pos] = byte(x)
					pos += 1
				case x <= 0xffff:
					buf[pos] = 0xfd
					binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
					pos += 3
				case x <= 0xffffffff:
					buf[pos] = 0xfe
					binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
					pos += 5
				default:
					buf[pos] = 0xff
					binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
					pos += 9
				}
				copy(buf[pos:], value.Params_k)
				pos += uint(len(value.Params_k))
				if value.Params_v != nil {
					buf[pos] = byte(135)
					pos += 1
					switch x := len(value.Params_v); {
					case x <= 0xfc:
						buf[pos] = byte(x)
						pos += 1
					case x <= 0xffff:
						buf[pos] = 0xfd
						binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
						pos += 3
					case x <= 0xffffffff:
						buf[pos] = 0xfe
						binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
						pos += 5
					default:
						buf[pos] = 0xff
						binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
						pos += 9
					}
					copy(buf[pos:], value.Params_v)
					pos += uint(len(value.Params_v))
				}
				_ = encoder
				_ = value
			}
		}
	}
}

func (encoder *StringMapEncoder) Encode(value *StringMap) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *StringMapParsingContext) Parse(reader enc.ParseReader, ignoreCritical bool) (*StringMap, error) {
	if reader == nil {
		return nil, enc.ErrBufferOverflow
	}

	var handled_Params bool = false

	progress := -1
	_ = progress

	value := &StringMap{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 133:
				if true {
					handled = true
					handled_Params = true
					if value.Params == nil {
						value.Params = make(map[string][]byte)
					}
					{
						pseudoValue := struct {
							Params_k string
							Params_v []byte
						}{}
						{
							value := &pseudoValue
							{
								var builder strings.Builder
								_, err = io.CopyN(&builder, reader, int64(l))
								if err == nil {
									value.Params_k = builder.String()
								}
							}
							typ := enc.TLNum(0)
							l := enc.TLNum(0)
							typ, err = enc.ReadTLNum(reader)
							if err != nil {
								return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
							}
							l, err = enc.ReadTLNum(reader)
							if err != nil {
								return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
							}
							if typ != 135 {
								return nil, enc.ErrFailToParse{TypeNum: 133, Err: enc.ErrUnrecognizedField{TypeNum: typ}}
							}
							value.Params_v = make([]byte, l)
							_, err = io.ReadFull(reader, value.Params_v)
							_ = value
						}
						value.Params[pseudoValue.Params_k] = pseudoValue.Params_v
					}
					progress--
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Params && err == nil {
		// map - skip
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *StringMap) Encode() enc.Wire {
	encoder := StringMapEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *StringMap) Bytes() []byte {
	return value.Encode().Join()
}

func ParseStringMap(reader enc.ParseReader, ignoreCritical bool) (*StringMap, error) {
	context := StringMapParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type InnerEncoder struct {
	length uint
}

type InnerParsingContext struct {
}

func (encoder *InnerEncoder) Init(value *Inner) {

	l := uint(0)
	l += 1
	switch x := value.Num; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	encoder.length = l

}

func (context *InnerParsingContext) Init() {

}

func (encoder *InnerEncoder) EncodeInto(value *Inner, buf []byte) {

	pos := uint(0)

	buf[pos] = byte(1)
	pos += 1
	switch x := value.Num; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
}

func (encoder *InnerEncoder) Encode(value *Inner) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *InnerParsingContext) Parse(reader enc.ParseReader, ignoreCritical bool) (*Inner, error) {
	if reader == nil {
		return nil, enc.ErrBufferOverflow
	}

	var handled_Num bool = false

	progress := -1
	_ = progress

	value := &Inner{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 1:
				if true {
					handled = true
					handled_Num = true
					value.Num = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.Num = uint64(value.Num<<8) | uint64(x)
						}
					}
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Num && err == nil {
		err = enc.ErrSkipRequired{Name: "Num", TypeNum: 1}
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *Inner) Encode() enc.Wire {
	encoder := InnerEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *Inner) Bytes() []byte {
	return value.Encode().Join()
}

func ParseInner(reader enc.ParseReader, ignoreCritical bool) (*Inner, error) {
	context := InnerParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type IntStructMapEncoder struct {
	length uint

	Params_valencoder map[uint64]*struct {
		Params_v_encoder InnerEncoder
	}
}

type IntStructMapParsingContext struct {
	Params_v_context InnerParsingContext
}

func (encoder *IntStructMapEncoder) Init(value *IntStructMap) {
	{
		Params_l := len(value.Params)
		encoder.Params_valencoder = make(map[uint64]*struct {
			Params_v_encoder InnerEncoder
		}, Params_l)
		for map_k := range value.Params {
			pseudoEncoder := &struct {
				Params_v_encoder InnerEncoder
			}{}
			encoder.Params_valencoder[map_k] = pseudoEncoder
			pseudoValue := struct {
				Params_v *Inner
			}{
				Params_v: value.Params[map_k],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Params_v != nil {
					encoder.Params_v_encoder.Init(value.Params_v)
				}
				_ = encoder
				_ = value
			}
		}
	}

	l := uint(0)
	if value.Params != nil {
		for map_k, map_v := range value.Params {
			pseudoEncoder := encoder.Params_valencoder[map_k]
			pseudoValue := struct {
				Params_k uint64
				Params_v *Inner
			}{
				Params_k: map_k,
				Params_v: map_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				l += 1
				switch x := value.Params_k; {
				case x <= 0xff:
					l += 2
				case x <= 0xffff:
					l += 3
				case x <= 0xffffffff:
					l += 5
				default:
					l += 9
				}
				if value.Params_v != nil {
					l += 1
					switch x := encoder.Params_v_encoder.length; {
					case x <= 0xfc:
						l += 1
					case x <= 0xffff:
						l += 3
					case x <= 0xffffffff:
						l += 5
					default:
						l += 9
					}
					l += encoder.Params_v_encoder.length
				}
				_ = encoder
				_ = value
			}
		}
	}
	encoder.length = l

}

func (context *IntStructMapParsingContext) Init() {
	context.Params_v_context.Init()
}

func (encoder *IntStructMapEncoder) EncodeInto(value *IntStructMap, buf []byte) {

	pos := uint(0)

	if value.Params != nil {
		for map_k, map_v := range value.Params {
			pseudoEncoder := encoder.Params_valencoder[map_k]
			pseudoValue := struct {
				Params_k uint64
				Params_v *Inner
			}{
				Params_k: map_k,
				Params_v: map_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				buf[pos] = byte(133)
				pos += 1
				switch x := value.Params_k; {
				case x <= 0xff:
					buf[pos] = 1
					buf[pos+1] = byte(x)
					pos += 2
				case x <= 0xffff:
					buf[pos] = 2
					binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
					pos += 3
				case x <= 0xffffffff:
					buf[pos] = 4
					binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
					pos += 5
				default:
					buf[pos] = 8
					binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
					pos += 9
				}
				if value.Params_v != nil {
					buf[pos] = byte(135)
					pos += 1
					switch x := encoder.Params_v_encoder.length; {
					case x <= 0xfc:
						buf[pos] = byte(x)
						pos += 1
					case x <= 0xffff:
						buf[pos] = 0xfd
						binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
						pos += 3
					case x <= 0xffffffff:
						buf[pos] = 0xfe
						binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
						pos += 5
					default:
						buf[pos] = 0xff
						binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
						pos += 9
					}
					if encoder.Params_v_encoder.length > 0 {
						encoder.Params_v_encoder.EncodeInto(value.Params_v, buf[pos:])
						pos += encoder.Params_v_encoder.length
					}
				}
				_ = encoder
				_ = value
			}
		}
	}
}

func (encoder *IntStructMapEncoder) Encode(value *IntStructMap) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *IntStructMapParsingContext) Parse(reader enc.ParseReader, ignoreCritical bool) (*IntStructMap, error) {
	if reader == nil {
		return nil, enc.ErrBufferOverflow
	}

	var handled_Params bool = false

	progress := -1
	_ = progress

	value := &IntStructMap{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 133:
				if true {
					handled = true
					handled_Params = true
					if value.Params == nil {
						value.Params = make(map[uint64]*Inner)
					}
					{
						pseudoValue := struct {
							Params_k uint64
							Params_v *Inner
						}{}
						{
							value := &pseudoValue
							value.Params_k = uint64(0)
							{
								for i := 0; i < int(l); i++ {
									x := byte(0)
									x, err = reader.ReadByte()
									if err != nil {
										if err == io.EOF {
											err = io.ErrUnexpectedEOF
										}
										break
									}
									value.Params_k = uint64(value.Params_k<<8) | uint64(x)
								}
							}
							typ := enc.TLNum(0)
							l := enc.TLNum(0)
							typ, err = enc.ReadTLNum(reader)
							if err != nil {
								return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
							}
							l, err = enc.ReadTLNum(reader)
							if err != nil {
								return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
							}
							if typ != 135 {
								return nil, enc.ErrFailToParse{TypeNum: 133, Err: enc.ErrUnrecognizedField{TypeNum: typ}}
							}
							value.Params_v, err = context.Params_v_context.Parse(reader.Delegate(int(l)), ignoreCritical)
							_ = value
						}
						value.Params[pseudoValue.Params_k] = pseudoValue.Params_v
					}
					progress--
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Params && err == nil {
		// map - skip
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *IntStructMap) Encode() enc.Wire {
	encoder := IntStructMapEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *IntStructMap) Bytes() []byte {
	return value.Encode().Join()
}

func ParseIntStructMap(reader enc.ParseReader, ignoreCritical bool) (*IntStructMap, error) {
	context := IntStructMapParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}
