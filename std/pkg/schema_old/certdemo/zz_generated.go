// Generated by the generator, DO NOT modify manually
package certdemo

import (
	"encoding/binary"
	"io"
	"strings"

	enc "github.com/zjkmxy/go-ndn/pkg/encoding"
)

type CaProfileEncoder struct {
	length uint

	CaPrefix_length uint

	ParamKey_subencoder []struct {
	}

	CaCert_length uint
}

type CaProfileParsingContext struct {
}

func (encoder *CaProfileEncoder) Init(value *CaProfile) {
	if value.CaPrefix != nil {
		encoder.CaPrefix_length = 0
		for _, c := range value.CaPrefix {
			encoder.CaPrefix_length += uint(c.EncodingLength())
		}
	}

	{
		ParamKey_l := len(value.ParamKey)
		encoder.ParamKey_subencoder = make([]struct {
		}, ParamKey_l)
		for i := 0; i < ParamKey_l; i++ {
			pseudoEncoder := &encoder.ParamKey_subencoder[i]
			pseudoValue := struct {
				ParamKey string
			}{
				ParamKey: value.ParamKey[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue

				_ = encoder
				_ = value
			}
		}
	}

	if value.CaCert != nil {
		encoder.CaCert_length = 0
		for _, c := range value.CaCert {
			encoder.CaCert_length += uint(len(c))
		}
	}

	l := uint(0)
	if value.CaPrefix != nil {
		l += 1
		switch x := encoder.CaPrefix_length; {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += encoder.CaPrefix_length
	}

	l += 1
	switch x := len(value.CaInfo); {
	case x <= 0xfc:
		l += 1
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += uint(len(value.CaInfo))

	if value.ParamKey != nil {
		for seq_i, seq_v := range value.ParamKey {
			pseudoEncoder := &encoder.ParamKey_subencoder[seq_i]
			pseudoValue := struct {
				ParamKey string
			}{
				ParamKey: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				l += 1
				switch x := len(value.ParamKey); {
				case x <= 0xfc:
					l += 1
				case x <= 0xffff:
					l += 3
				case x <= 0xffffffff:
					l += 5
				default:
					l += 9
				}
				l += uint(len(value.ParamKey))

				_ = encoder
				_ = value
			}
		}
	}

	l += 1
	switch x := value.MaxValidPeriod; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}

	if value.CaCert != nil {
		l += 1
		switch x := encoder.CaCert_length; {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += encoder.CaCert_length
	}

	encoder.length = l

}

func (context *CaProfileParsingContext) Init() {

}

func (encoder *CaProfileEncoder) EncodeInto(value *CaProfile, buf []byte) {

	pos := uint(0)
	if value.CaPrefix != nil {
		buf[pos] = byte(129)
		pos += 1
		switch x := encoder.CaPrefix_length; {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		for _, c := range value.CaPrefix {
			pos += uint(c.EncodeInto(buf[pos:]))
		}
	}

	buf[pos] = byte(131)
	pos += 1
	switch x := len(value.CaInfo); {
	case x <= 0xfc:
		buf[pos] = byte(x)
		pos += 1
	case x <= 0xffff:
		buf[pos] = 0xfd
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 0xfe
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 0xff
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	copy(buf[pos:], value.CaInfo)
	pos += uint(len(value.CaInfo))

	if value.ParamKey != nil {
		for seq_i, seq_v := range value.ParamKey {
			pseudoEncoder := &encoder.ParamKey_subencoder[seq_i]
			pseudoValue := struct {
				ParamKey string
			}{
				ParamKey: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				buf[pos] = byte(133)
				pos += 1
				switch x := len(value.ParamKey); {
				case x <= 0xfc:
					buf[pos] = byte(x)
					pos += 1
				case x <= 0xffff:
					buf[pos] = 0xfd
					binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
					pos += 3
				case x <= 0xffffffff:
					buf[pos] = 0xfe
					binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
					pos += 5
				default:
					buf[pos] = 0xff
					binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
					pos += 9
				}
				copy(buf[pos:], value.ParamKey)
				pos += uint(len(value.ParamKey))

				_ = encoder
				_ = value
			}
		}
	}

	buf[pos] = byte(139)
	pos += 1
	switch x := value.MaxValidPeriod; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}

	if value.CaCert != nil {
		buf[pos] = byte(137)
		pos += 1
		switch x := encoder.CaCert_length; {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		for _, w := range value.CaCert {
			copy(buf[pos:], w)
			pos += uint(len(w))
		}
	}

}

func (encoder *CaProfileEncoder) Encode(value *CaProfile) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *CaProfileParsingContext) Parse(reader enc.ParseReader, ignoreCritical bool) (*CaProfile, error) {
	if reader == nil {
		return nil, enc.ErrBufferOverflow
	}
	progress := -1
	value := &CaProfile{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		err = nil
		for handled := false; !handled; progress++ {
			switch typ {
			case 129:
				if progress+1 == 0 {
					handled = true
					value.CaPrefix = make(enc.Name, l/2+1)
					startName := reader.Pos()
					endName := startName + int(l)
					for j := range value.CaPrefix {
						if reader.Pos() >= endName {
							value.CaPrefix = value.CaPrefix[:j]
							break
						}
						var err1, err3 error
						value.CaPrefix[j].Typ, err1 = enc.ReadTLNum(reader)
						l, err2 := enc.ReadTLNum(reader)
						value.CaPrefix[j].Val, err3 = reader.ReadBuf(int(l))
						if err1 != nil || err2 != nil || err3 != nil {
							err = io.ErrUnexpectedEOF
							break
						}
					}
					if err == nil && reader.Pos() != endName {
						err = enc.ErrBufferOverflow
					}

				}
			case 131:
				if progress+1 == 1 {
					handled = true
					{
						var builder strings.Builder
						_, err = io.CopyN(&builder, reader, int64(l))
						if err == nil {
							value.CaInfo = builder.String()
						}
					}

				}
			case 133:
				if progress+1 == 2 {
					handled = true
					if value.ParamKey == nil {
						value.ParamKey = make([]string, 0)
					}
					{
						pseudoValue := struct {
							ParamKey string
						}{}
						{
							value := &pseudoValue
							{
								var builder strings.Builder
								_, err = io.CopyN(&builder, reader, int64(l))
								if err == nil {
									value.ParamKey = builder.String()
								}
							}

							_ = value
						}
						value.ParamKey = append(value.ParamKey, pseudoValue.ParamKey)
					}
					progress--

				}
			case 139:
				if progress+1 == 3 {
					handled = true
					value.MaxValidPeriod = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.MaxValidPeriod = uint64(value.MaxValidPeriod<<8) | uint64(x)
						}
					}
				}
			case 137:
				if progress+1 == 4 {
					handled = true
					value.CaCert, err = reader.ReadWire(int(l))

				}
			default:
				handled = true
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
				switch progress {
				case 0 - 1:
					value.CaPrefix = nil
				case 1 - 1:
					err = enc.ErrSkipRequired{Name: "CaInfo", TypeNum: 131}
				case 2 - 1:

				case 3 - 1:
					err = enc.ErrSkipRequired{Name: "MaxValidPeriod", TypeNum: 139}
				case 4 - 1:
					value.CaCert = nil
				}
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}
	startPos = reader.Pos()
	for ; progress < 5; progress++ {
		switch progress {
		case 0 - 1:
			value.CaPrefix = nil
		case 1 - 1:
			err = enc.ErrSkipRequired{Name: "CaInfo", TypeNum: 131}
		case 2 - 1:

		case 3 - 1:
			err = enc.ErrSkipRequired{Name: "MaxValidPeriod", TypeNum: 139}
		case 4 - 1:
			value.CaCert = nil
		}
	}
	if err != nil {
		return nil, err
	}
	return value, nil
}

func (value *CaProfile) Encode() enc.Wire {
	encoder := CaProfileEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *CaProfile) Bytes() []byte {
	return value.Encode().Join()
}

func ParseCaProfile(reader enc.ParseReader, ignoreCritical bool) (*CaProfile, error) {
	context := CaProfileParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type ParamEncoder struct {
	length uint
}

type ParamParsingContext struct {
}

func (encoder *ParamEncoder) Init(value *Param) {

	l := uint(0)
	l += 1
	switch x := len(value.ParamKey); {
	case x <= 0xfc:
		l += 1
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += uint(len(value.ParamKey))

	if value.ParamValue != nil {
		l += 1
		switch x := len(value.ParamValue); {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += uint(len(value.ParamValue))
	}

	encoder.length = l

}

func (context *ParamParsingContext) Init() {

}

func (encoder *ParamEncoder) EncodeInto(value *Param, buf []byte) {

	pos := uint(0)
	buf[pos] = byte(133)
	pos += 1
	switch x := len(value.ParamKey); {
	case x <= 0xfc:
		buf[pos] = byte(x)
		pos += 1
	case x <= 0xffff:
		buf[pos] = 0xfd
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 0xfe
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 0xff
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	copy(buf[pos:], value.ParamKey)
	pos += uint(len(value.ParamKey))

	if value.ParamValue != nil {
		buf[pos] = byte(135)
		pos += 1
		switch x := len(value.ParamValue); {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		copy(buf[pos:], value.ParamValue)
		pos += uint(len(value.ParamValue))
	}

}

func (encoder *ParamEncoder) Encode(value *Param) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *ParamParsingContext) Parse(reader enc.ParseReader, ignoreCritical bool) (*Param, error) {
	if reader == nil {
		return nil, enc.ErrBufferOverflow
	}
	progress := -1
	value := &Param{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		err = nil
		for handled := false; !handled; progress++ {
			switch typ {
			case 133:
				if progress+1 == 0 {
					handled = true
					{
						var builder strings.Builder
						_, err = io.CopyN(&builder, reader, int64(l))
						if err == nil {
							value.ParamKey = builder.String()
						}
					}

				}
			case 135:
				if progress+1 == 1 {
					handled = true
					value.ParamValue = make([]byte, l)
					_, err = io.ReadFull(reader, value.ParamValue)

				}
			default:
				handled = true
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
				switch progress {
				case 0 - 1:
					err = enc.ErrSkipRequired{Name: "ParamKey", TypeNum: 133}
				case 1 - 1:
					value.ParamValue = nil
				}
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}
	startPos = reader.Pos()
	for ; progress < 2; progress++ {
		switch progress {
		case 0 - 1:
			err = enc.ErrSkipRequired{Name: "ParamKey", TypeNum: 133}
		case 1 - 1:
			value.ParamValue = nil
		}
	}
	if err != nil {
		return nil, err
	}
	return value, nil
}

func (value *Param) Encode() enc.Wire {
	encoder := ParamEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *Param) Bytes() []byte {
	return value.Encode().Join()
}

func ParseParam(reader enc.ParseReader, ignoreCritical bool) (*Param, error) {
	context := ParamParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type ProbeIntEncoder struct {
	length uint

	Params_subencoder []struct {
		Params_encoder ParamEncoder
	}
}

type ProbeIntParsingContext struct {
	Params_context ParamParsingContext
}

func (encoder *ProbeIntEncoder) Init(value *ProbeInt) {
	{
		Params_l := len(value.Params)
		encoder.Params_subencoder = make([]struct {
			Params_encoder ParamEncoder
		}, Params_l)
		for i := 0; i < Params_l; i++ {
			pseudoEncoder := &encoder.Params_subencoder[i]
			pseudoValue := struct {
				Params *Param
			}{
				Params: value.Params[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Params != nil {
					encoder.Params_encoder.Init(value.Params)
				}
				_ = encoder
				_ = value
			}
		}
	}

	l := uint(0)
	if value.Params != nil {
		for seq_i, seq_v := range value.Params {
			pseudoEncoder := &encoder.Params_subencoder[seq_i]
			pseudoValue := struct {
				Params *Param
			}{
				Params: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Params != nil {
					l += 1
					switch x := encoder.Params_encoder.length; {
					case x <= 0xfc:
						l += 1
					case x <= 0xffff:
						l += 3
					case x <= 0xffffffff:
						l += 5
					default:
						l += 9
					}
					l += encoder.Params_encoder.length
				}

				_ = encoder
				_ = value
			}
		}
	}

	encoder.length = l

}

func (context *ProbeIntParsingContext) Init() {
	context.Params_context.Init()
}

func (encoder *ProbeIntEncoder) EncodeInto(value *ProbeInt, buf []byte) {

	pos := uint(0)
	if value.Params != nil {
		for seq_i, seq_v := range value.Params {
			pseudoEncoder := &encoder.Params_subencoder[seq_i]
			pseudoValue := struct {
				Params *Param
			}{
				Params: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Params != nil {
					buf[pos] = byte(193)
					pos += 1
					switch x := encoder.Params_encoder.length; {
					case x <= 0xfc:
						buf[pos] = byte(x)
						pos += 1
					case x <= 0xffff:
						buf[pos] = 0xfd
						binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
						pos += 3
					case x <= 0xffffffff:
						buf[pos] = 0xfe
						binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
						pos += 5
					default:
						buf[pos] = 0xff
						binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
						pos += 9
					}
					if encoder.Params_encoder.length > 0 {
						encoder.Params_encoder.EncodeInto(value.Params, buf[pos:])
						pos += encoder.Params_encoder.length
					}
				}

				_ = encoder
				_ = value
			}
		}
	}

}

func (encoder *ProbeIntEncoder) Encode(value *ProbeInt) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *ProbeIntParsingContext) Parse(reader enc.ParseReader, ignoreCritical bool) (*ProbeInt, error) {
	if reader == nil {
		return nil, enc.ErrBufferOverflow
	}
	progress := -1
	value := &ProbeInt{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		err = nil
		for handled := false; !handled; progress++ {
			switch typ {
			case 193:
				if progress+1 == 0 {
					handled = true
					if value.Params == nil {
						value.Params = make([]*Param, 0)
					}
					{
						pseudoValue := struct {
							Params *Param
						}{}
						{
							value := &pseudoValue
							value.Params, err = context.Params_context.Parse(reader.Delegate(int(l)), ignoreCritical)
							_ = value
						}
						value.Params = append(value.Params, pseudoValue.Params)
					}
					progress--

				}
			default:
				handled = true
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
				switch progress {
				case 0 - 1:

				}
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}
	startPos = reader.Pos()
	for ; progress < 1; progress++ {
		switch progress {
		case 0 - 1:

		}
	}
	if err != nil {
		return nil, err
	}
	return value, nil
}

func (value *ProbeInt) Encode() enc.Wire {
	encoder := ProbeIntEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *ProbeInt) Bytes() []byte {
	return value.Encode().Join()
}

func ParseProbeInt(reader enc.ParseReader, ignoreCritical bool) (*ProbeInt, error) {
	context := ProbeIntParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type ProbeResEncoder struct {
	length uint

	Response_length uint
}

type ProbeResParsingContext struct {
}

func (encoder *ProbeResEncoder) Init(value *ProbeRes) {
	if value.Response != nil {
		encoder.Response_length = 0
		for _, c := range value.Response {
			encoder.Response_length += uint(c.EncodingLength())
		}
	}

	l := uint(0)
	if value.Response != nil {
		l += 1
		switch x := encoder.Response_length; {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += encoder.Response_length
	}

	if value.MaxSuffixLength != nil {
		l += 1
		switch x := *value.MaxSuffixLength; {
		case x <= 0xff:
			l += 2
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
	}

	encoder.length = l

}

func (context *ProbeResParsingContext) Init() {

}

func (encoder *ProbeResEncoder) EncodeInto(value *ProbeRes, buf []byte) {

	pos := uint(0)
	if value.Response != nil {
		buf[pos] = byte(141)
		pos += 1
		switch x := encoder.Response_length; {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		for _, c := range value.Response {
			pos += uint(c.EncodeInto(buf[pos:]))
		}
	}

	if value.MaxSuffixLength != nil {
		buf[pos] = byte(0)
		pos += 1
		switch x := *value.MaxSuffixLength; {
		case x <= 0xff:
			buf[pos] = 1
			buf[pos+1] = byte(x)
			pos += 2
		case x <= 0xffff:
			buf[pos] = 2
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 4
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 8
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
	}

}

func (encoder *ProbeResEncoder) Encode(value *ProbeRes) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *ProbeResParsingContext) Parse(reader enc.ParseReader, ignoreCritical bool) (*ProbeRes, error) {
	if reader == nil {
		return nil, enc.ErrBufferOverflow
	}
	progress := -1
	value := &ProbeRes{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		err = nil
		for handled := false; !handled; progress++ {
			switch typ {
			case 141:
				if progress+1 == 0 {
					handled = true
					value.Response = make(enc.Name, l/2+1)
					startName := reader.Pos()
					endName := startName + int(l)
					for j := range value.Response {
						if reader.Pos() >= endName {
							value.Response = value.Response[:j]
							break
						}
						var err1, err3 error
						value.Response[j].Typ, err1 = enc.ReadTLNum(reader)
						l, err2 := enc.ReadTLNum(reader)
						value.Response[j].Val, err3 = reader.ReadBuf(int(l))
						if err1 != nil || err2 != nil || err3 != nil {
							err = io.ErrUnexpectedEOF
							break
						}
					}
					if err == nil && reader.Pos() != endName {
						err = enc.ErrBufferOverflow
					}

				}
			default:
				handled = true
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
				switch progress {
				case 0 - 1:
					value.Response = nil
				case 1 - 1:
					value.MaxSuffixLength = nil
				}
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}
	startPos = reader.Pos()
	for ; progress < 2; progress++ {
		switch progress {
		case 0 - 1:
			value.Response = nil
		case 1 - 1:
			value.MaxSuffixLength = nil
		}
	}
	if err != nil {
		return nil, err
	}
	return value, nil
}

func (value *ProbeRes) Encode() enc.Wire {
	encoder := ProbeResEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *ProbeRes) Bytes() []byte {
	return value.Encode().Join()
}

func ParseProbeRes(reader enc.ParseReader, ignoreCritical bool) (*ProbeRes, error) {
	context := ProbeResParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type CmdNewIntEncoder struct {
	length uint
}

type CmdNewIntParsingContext struct {
}

func (encoder *CmdNewIntEncoder) Init(value *CmdNewInt) {

	l := uint(0)
	if value.EcdhPub != nil {
		l += 1
		switch x := len(value.EcdhPub); {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += uint(len(value.EcdhPub))
	}

	if value.CertReq != nil {
		l += 1
		switch x := len(value.CertReq); {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += uint(len(value.CertReq))
	}

	encoder.length = l

}

func (context *CmdNewIntParsingContext) Init() {

}

func (encoder *CmdNewIntEncoder) EncodeInto(value *CmdNewInt, buf []byte) {

	pos := uint(0)
	if value.EcdhPub != nil {
		buf[pos] = byte(145)
		pos += 1
		switch x := len(value.EcdhPub); {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		copy(buf[pos:], value.EcdhPub)
		pos += uint(len(value.EcdhPub))
	}

	if value.CertReq != nil {
		buf[pos] = byte(147)
		pos += 1
		switch x := len(value.CertReq); {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		copy(buf[pos:], value.CertReq)
		pos += uint(len(value.CertReq))
	}

}

func (encoder *CmdNewIntEncoder) Encode(value *CmdNewInt) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *CmdNewIntParsingContext) Parse(reader enc.ParseReader, ignoreCritical bool) (*CmdNewInt, error) {
	if reader == nil {
		return nil, enc.ErrBufferOverflow
	}
	progress := -1
	value := &CmdNewInt{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		err = nil
		for handled := false; !handled; progress++ {
			switch typ {
			case 145:
				if progress+1 == 0 {
					handled = true
					value.EcdhPub = make([]byte, l)
					_, err = io.ReadFull(reader, value.EcdhPub)

				}
			case 147:
				if progress+1 == 1 {
					handled = true
					value.CertReq = make([]byte, l)
					_, err = io.ReadFull(reader, value.CertReq)

				}
			default:
				handled = true
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
				switch progress {
				case 0 - 1:
					value.EcdhPub = nil
				case 1 - 1:
					value.CertReq = nil
				}
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}
	startPos = reader.Pos()
	for ; progress < 2; progress++ {
		switch progress {
		case 0 - 1:
			value.EcdhPub = nil
		case 1 - 1:
			value.CertReq = nil
		}
	}
	if err != nil {
		return nil, err
	}
	return value, nil
}

func (value *CmdNewInt) Encode() enc.Wire {
	encoder := CmdNewIntEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *CmdNewInt) Bytes() []byte {
	return value.Encode().Join()
}

func ParseCmdNewInt(reader enc.ParseReader, ignoreCritical bool) (*CmdNewInt, error) {
	context := CmdNewIntParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type CmdNewDataEncoder struct {
	length uint

	Challenge_subencoder []struct {
	}
}

type CmdNewDataParsingContext struct {
}

func (encoder *CmdNewDataEncoder) Init(value *CmdNewData) {

	{
		Challenge_l := len(value.Challenge)
		encoder.Challenge_subencoder = make([]struct {
		}, Challenge_l)
		for i := 0; i < Challenge_l; i++ {
			pseudoEncoder := &encoder.Challenge_subencoder[i]
			pseudoValue := struct {
				Challenge string
			}{
				Challenge: value.Challenge[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue

				_ = encoder
				_ = value
			}
		}
	}

	l := uint(0)
	if value.EcdhPub != nil {
		l += 1
		switch x := len(value.EcdhPub); {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += uint(len(value.EcdhPub))
	}

	if value.Salt != nil {
		l += 1
		switch x := len(value.Salt); {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += uint(len(value.Salt))
	}

	if value.ReqId != nil {
		l += 1
		switch x := len(value.ReqId); {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += uint(len(value.ReqId))
	}

	if value.Challenge != nil {
		for seq_i, seq_v := range value.Challenge {
			pseudoEncoder := &encoder.Challenge_subencoder[seq_i]
			pseudoValue := struct {
				Challenge string
			}{
				Challenge: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				l += 1
				switch x := len(value.Challenge); {
				case x <= 0xfc:
					l += 1
				case x <= 0xffff:
					l += 3
				case x <= 0xffffffff:
					l += 5
				default:
					l += 9
				}
				l += uint(len(value.Challenge))

				_ = encoder
				_ = value
			}
		}
	}

	encoder.length = l

}

func (context *CmdNewDataParsingContext) Init() {

}

func (encoder *CmdNewDataEncoder) EncodeInto(value *CmdNewData, buf []byte) {

	pos := uint(0)
	if value.EcdhPub != nil {
		buf[pos] = byte(145)
		pos += 1
		switch x := len(value.EcdhPub); {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		copy(buf[pos:], value.EcdhPub)
		pos += uint(len(value.EcdhPub))
	}

	if value.Salt != nil {
		buf[pos] = byte(149)
		pos += 1
		switch x := len(value.Salt); {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		copy(buf[pos:], value.Salt)
		pos += uint(len(value.Salt))
	}

	if value.ReqId != nil {
		buf[pos] = byte(151)
		pos += 1
		switch x := len(value.ReqId); {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		copy(buf[pos:], value.ReqId)
		pos += uint(len(value.ReqId))
	}

	if value.Challenge != nil {
		for seq_i, seq_v := range value.Challenge {
			pseudoEncoder := &encoder.Challenge_subencoder[seq_i]
			pseudoValue := struct {
				Challenge string
			}{
				Challenge: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				buf[pos] = byte(153)
				pos += 1
				switch x := len(value.Challenge); {
				case x <= 0xfc:
					buf[pos] = byte(x)
					pos += 1
				case x <= 0xffff:
					buf[pos] = 0xfd
					binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
					pos += 3
				case x <= 0xffffffff:
					buf[pos] = 0xfe
					binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
					pos += 5
				default:
					buf[pos] = 0xff
					binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
					pos += 9
				}
				copy(buf[pos:], value.Challenge)
				pos += uint(len(value.Challenge))

				_ = encoder
				_ = value
			}
		}
	}

}

func (encoder *CmdNewDataEncoder) Encode(value *CmdNewData) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *CmdNewDataParsingContext) Parse(reader enc.ParseReader, ignoreCritical bool) (*CmdNewData, error) {
	if reader == nil {
		return nil, enc.ErrBufferOverflow
	}
	progress := -1
	value := &CmdNewData{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		err = nil
		for handled := false; !handled; progress++ {
			switch typ {
			case 145:
				if progress+1 == 0 {
					handled = true
					value.EcdhPub = make([]byte, l)
					_, err = io.ReadFull(reader, value.EcdhPub)

				}
			case 149:
				if progress+1 == 1 {
					handled = true
					value.Salt = make([]byte, l)
					_, err = io.ReadFull(reader, value.Salt)

				}
			case 151:
				if progress+1 == 2 {
					handled = true
					value.ReqId = make([]byte, l)
					_, err = io.ReadFull(reader, value.ReqId)

				}
			case 153:
				if progress+1 == 3 {
					handled = true
					if value.Challenge == nil {
						value.Challenge = make([]string, 0)
					}
					{
						pseudoValue := struct {
							Challenge string
						}{}
						{
							value := &pseudoValue
							{
								var builder strings.Builder
								_, err = io.CopyN(&builder, reader, int64(l))
								if err == nil {
									value.Challenge = builder.String()
								}
							}

							_ = value
						}
						value.Challenge = append(value.Challenge, pseudoValue.Challenge)
					}
					progress--

				}
			default:
				handled = true
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
				switch progress {
				case 0 - 1:
					value.EcdhPub = nil
				case 1 - 1:
					value.Salt = nil
				case 2 - 1:
					value.ReqId = nil
				case 3 - 1:

				}
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}
	startPos = reader.Pos()
	for ; progress < 4; progress++ {
		switch progress {
		case 0 - 1:
			value.EcdhPub = nil
		case 1 - 1:
			value.Salt = nil
		case 2 - 1:
			value.ReqId = nil
		case 3 - 1:

		}
	}
	if err != nil {
		return nil, err
	}
	return value, nil
}

func (value *CmdNewData) Encode() enc.Wire {
	encoder := CmdNewDataEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *CmdNewData) Bytes() []byte {
	return value.Encode().Join()
}

func ParseCmdNewData(reader enc.ParseReader, ignoreCritical bool) (*CmdNewData, error) {
	context := CmdNewDataParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type ChallengeIntPlainEncoder struct {
	length uint

	Params_subencoder []struct {
		Params_encoder ParamEncoder
	}
}

type ChallengeIntPlainParsingContext struct {
	Params_context ParamParsingContext
}

func (encoder *ChallengeIntPlainEncoder) Init(value *ChallengeIntPlain) {

	{
		Params_l := len(value.Params)
		encoder.Params_subencoder = make([]struct {
			Params_encoder ParamEncoder
		}, Params_l)
		for i := 0; i < Params_l; i++ {
			pseudoEncoder := &encoder.Params_subencoder[i]
			pseudoValue := struct {
				Params *Param
			}{
				Params: value.Params[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Params != nil {
					encoder.Params_encoder.Init(value.Params)
				}
				_ = encoder
				_ = value
			}
		}
	}

	l := uint(0)
	l += 1
	switch x := len(value.SelectedChal); {
	case x <= 0xfc:
		l += 1
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += uint(len(value.SelectedChal))

	if value.Params != nil {
		for seq_i, seq_v := range value.Params {
			pseudoEncoder := &encoder.Params_subencoder[seq_i]
			pseudoValue := struct {
				Params *Param
			}{
				Params: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Params != nil {
					l += 1
					switch x := encoder.Params_encoder.length; {
					case x <= 0xfc:
						l += 1
					case x <= 0xffff:
						l += 3
					case x <= 0xffffffff:
						l += 5
					default:
						l += 9
					}
					l += encoder.Params_encoder.length
				}

				_ = encoder
				_ = value
			}
		}
	}

	encoder.length = l

}

func (context *ChallengeIntPlainParsingContext) Init() {

	context.Params_context.Init()
}

func (encoder *ChallengeIntPlainEncoder) EncodeInto(value *ChallengeIntPlain, buf []byte) {

	pos := uint(0)
	buf[pos] = byte(161)
	pos += 1
	switch x := len(value.SelectedChal); {
	case x <= 0xfc:
		buf[pos] = byte(x)
		pos += 1
	case x <= 0xffff:
		buf[pos] = 0xfd
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 0xfe
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 0xff
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	copy(buf[pos:], value.SelectedChal)
	pos += uint(len(value.SelectedChal))

	if value.Params != nil {
		for seq_i, seq_v := range value.Params {
			pseudoEncoder := &encoder.Params_subencoder[seq_i]
			pseudoValue := struct {
				Params *Param
			}{
				Params: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Params != nil {
					buf[pos] = byte(193)
					pos += 1
					switch x := encoder.Params_encoder.length; {
					case x <= 0xfc:
						buf[pos] = byte(x)
						pos += 1
					case x <= 0xffff:
						buf[pos] = 0xfd
						binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
						pos += 3
					case x <= 0xffffffff:
						buf[pos] = 0xfe
						binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
						pos += 5
					default:
						buf[pos] = 0xff
						binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
						pos += 9
					}
					if encoder.Params_encoder.length > 0 {
						encoder.Params_encoder.EncodeInto(value.Params, buf[pos:])
						pos += encoder.Params_encoder.length
					}
				}

				_ = encoder
				_ = value
			}
		}
	}

}

func (encoder *ChallengeIntPlainEncoder) Encode(value *ChallengeIntPlain) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *ChallengeIntPlainParsingContext) Parse(reader enc.ParseReader, ignoreCritical bool) (*ChallengeIntPlain, error) {
	if reader == nil {
		return nil, enc.ErrBufferOverflow
	}
	progress := -1
	value := &ChallengeIntPlain{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		err = nil
		for handled := false; !handled; progress++ {
			switch typ {
			case 161:
				if progress+1 == 0 {
					handled = true
					{
						var builder strings.Builder
						_, err = io.CopyN(&builder, reader, int64(l))
						if err == nil {
							value.SelectedChal = builder.String()
						}
					}

				}
			case 193:
				if progress+1 == 1 {
					handled = true
					if value.Params == nil {
						value.Params = make([]*Param, 0)
					}
					{
						pseudoValue := struct {
							Params *Param
						}{}
						{
							value := &pseudoValue
							value.Params, err = context.Params_context.Parse(reader.Delegate(int(l)), ignoreCritical)
							_ = value
						}
						value.Params = append(value.Params, pseudoValue.Params)
					}
					progress--

				}
			default:
				handled = true
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
				switch progress {
				case 0 - 1:
					err = enc.ErrSkipRequired{Name: "SelectedChal", TypeNum: 161}
				case 1 - 1:

				}
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}
	startPos = reader.Pos()
	for ; progress < 2; progress++ {
		switch progress {
		case 0 - 1:
			err = enc.ErrSkipRequired{Name: "SelectedChal", TypeNum: 161}
		case 1 - 1:

		}
	}
	if err != nil {
		return nil, err
	}
	return value, nil
}

func (value *ChallengeIntPlain) Encode() enc.Wire {
	encoder := ChallengeIntPlainEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *ChallengeIntPlain) Bytes() []byte {
	return value.Encode().Join()
}

func ParseChallengeIntPlain(reader enc.ParseReader, ignoreCritical bool) (*ChallengeIntPlain, error) {
	context := ChallengeIntPlainParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type ChallengeDataPlainEncoder struct {
	length uint

	CertName_length       uint
	ForwardingHint_length uint
	Params_subencoder     []struct {
		Params_encoder ParamEncoder
	}
}

type ChallengeDataPlainParsingContext struct {
	Params_context ParamParsingContext
}

func (encoder *ChallengeDataPlainEncoder) Init(value *ChallengeDataPlain) {

	if value.CertName != nil {
		encoder.CertName_length = 0
		for _, c := range value.CertName {
			encoder.CertName_length += uint(c.EncodingLength())
		}
	}

	if value.ForwardingHint != nil {
		encoder.ForwardingHint_length = 0
		for _, c := range value.ForwardingHint {
			encoder.ForwardingHint_length += uint(c.EncodingLength())
		}
	}

	{
		Params_l := len(value.Params)
		encoder.Params_subencoder = make([]struct {
			Params_encoder ParamEncoder
		}, Params_l)
		for i := 0; i < Params_l; i++ {
			pseudoEncoder := &encoder.Params_subencoder[i]
			pseudoValue := struct {
				Params *Param
			}{
				Params: value.Params[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Params != nil {
					encoder.Params_encoder.Init(value.Params)
				}
				_ = encoder
				_ = value
			}
		}
	}

	l := uint(0)
	l += 1
	switch x := value.Status; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}

	if value.ChalStatus != nil {
		l += 1
		switch x := *value.ChalStatus; {
		case x <= 0xff:
			l += 2
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
	}

	if value.RemainTries != nil {
		l += 1
		switch x := *value.RemainTries; {
		case x <= 0xff:
			l += 2
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
	}

	if value.RemainTime != nil {
		l += 1
		switch x := *value.RemainTime; {
		case x <= 0xff:
			l += 2
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
	}

	if value.CertName != nil {
		l += 1
		switch x := encoder.CertName_length; {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += encoder.CertName_length
	}

	if value.ForwardingHint != nil {
		l += 1
		switch x := encoder.ForwardingHint_length; {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += encoder.ForwardingHint_length
	}

	if value.Params != nil {
		for seq_i, seq_v := range value.Params {
			pseudoEncoder := &encoder.Params_subencoder[seq_i]
			pseudoValue := struct {
				Params *Param
			}{
				Params: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Params != nil {
					l += 1
					switch x := encoder.Params_encoder.length; {
					case x <= 0xfc:
						l += 1
					case x <= 0xffff:
						l += 3
					case x <= 0xffffffff:
						l += 5
					default:
						l += 9
					}
					l += encoder.Params_encoder.length
				}

				_ = encoder
				_ = value
			}
		}
	}

	encoder.length = l

}

func (context *ChallengeDataPlainParsingContext) Init() {

	context.Params_context.Init()
}

func (encoder *ChallengeDataPlainEncoder) EncodeInto(value *ChallengeDataPlain, buf []byte) {

	pos := uint(0)
	buf[pos] = byte(155)
	pos += 1
	switch x := value.Status; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}

	if value.ChalStatus != nil {
		buf[pos] = byte(163)
		pos += 1
		switch x := *value.ChalStatus; {
		case x <= 0xff:
			buf[pos] = 1
			buf[pos+1] = byte(x)
			pos += 2
		case x <= 0xffff:
			buf[pos] = 2
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 4
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 8
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
	}

	if value.RemainTries != nil {
		buf[pos] = byte(165)
		pos += 1
		switch x := *value.RemainTries; {
		case x <= 0xff:
			buf[pos] = 1
			buf[pos+1] = byte(x)
			pos += 2
		case x <= 0xffff:
			buf[pos] = 2
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 4
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 8
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
	}

	if value.RemainTime != nil {
		buf[pos] = byte(167)
		pos += 1
		switch x := *value.RemainTime; {
		case x <= 0xff:
			buf[pos] = 1
			buf[pos+1] = byte(x)
			pos += 2
		case x <= 0xffff:
			buf[pos] = 2
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 4
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 8
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
	}

	if value.CertName != nil {
		buf[pos] = byte(169)
		pos += 1
		switch x := encoder.CertName_length; {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		for _, c := range value.CertName {
			pos += uint(c.EncodeInto(buf[pos:]))
		}
	}

	if value.ForwardingHint != nil {
		buf[pos] = byte(30)
		pos += 1
		switch x := encoder.ForwardingHint_length; {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		for _, c := range value.ForwardingHint {
			pos += uint(c.EncodeInto(buf[pos:]))
		}
	}

	if value.Params != nil {
		for seq_i, seq_v := range value.Params {
			pseudoEncoder := &encoder.Params_subencoder[seq_i]
			pseudoValue := struct {
				Params *Param
			}{
				Params: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Params != nil {
					buf[pos] = byte(193)
					pos += 1
					switch x := encoder.Params_encoder.length; {
					case x <= 0xfc:
						buf[pos] = byte(x)
						pos += 1
					case x <= 0xffff:
						buf[pos] = 0xfd
						binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
						pos += 3
					case x <= 0xffffffff:
						buf[pos] = 0xfe
						binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
						pos += 5
					default:
						buf[pos] = 0xff
						binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
						pos += 9
					}
					if encoder.Params_encoder.length > 0 {
						encoder.Params_encoder.EncodeInto(value.Params, buf[pos:])
						pos += encoder.Params_encoder.length
					}
				}

				_ = encoder
				_ = value
			}
		}
	}

}

func (encoder *ChallengeDataPlainEncoder) Encode(value *ChallengeDataPlain) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *ChallengeDataPlainParsingContext) Parse(reader enc.ParseReader, ignoreCritical bool) (*ChallengeDataPlain, error) {
	if reader == nil {
		return nil, enc.ErrBufferOverflow
	}
	progress := -1
	value := &ChallengeDataPlain{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		err = nil
		for handled := false; !handled; progress++ {
			switch typ {
			case 155:
				if progress+1 == 0 {
					handled = true
					value.Status = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.Status = uint64(value.Status<<8) | uint64(x)
						}
					}
				}
			case 163:
				if progress+1 == 1 {
					handled = true
					{
						tempVal := uint64(0)
						tempVal = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								tempVal = uint64(tempVal<<8) | uint64(x)
							}
						}
						value.ChalStatus = &tempVal
					}

				}
			case 165:
				if progress+1 == 2 {
					handled = true
					{
						tempVal := uint64(0)
						tempVal = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								tempVal = uint64(tempVal<<8) | uint64(x)
							}
						}
						value.RemainTries = &tempVal
					}

				}
			case 167:
				if progress+1 == 3 {
					handled = true
					{
						tempVal := uint64(0)
						tempVal = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								tempVal = uint64(tempVal<<8) | uint64(x)
							}
						}
						value.RemainTime = &tempVal
					}

				}
			case 169:
				if progress+1 == 4 {
					handled = true
					value.CertName = make(enc.Name, l/2+1)
					startName := reader.Pos()
					endName := startName + int(l)
					for j := range value.CertName {
						if reader.Pos() >= endName {
							value.CertName = value.CertName[:j]
							break
						}
						var err1, err3 error
						value.CertName[j].Typ, err1 = enc.ReadTLNum(reader)
						l, err2 := enc.ReadTLNum(reader)
						value.CertName[j].Val, err3 = reader.ReadBuf(int(l))
						if err1 != nil || err2 != nil || err3 != nil {
							err = io.ErrUnexpectedEOF
							break
						}
					}
					if err == nil && reader.Pos() != endName {
						err = enc.ErrBufferOverflow
					}

				}
			case 30:
				if progress+1 == 5 {
					handled = true
					value.ForwardingHint = make(enc.Name, l/2+1)
					startName := reader.Pos()
					endName := startName + int(l)
					for j := range value.ForwardingHint {
						if reader.Pos() >= endName {
							value.ForwardingHint = value.ForwardingHint[:j]
							break
						}
						var err1, err3 error
						value.ForwardingHint[j].Typ, err1 = enc.ReadTLNum(reader)
						l, err2 := enc.ReadTLNum(reader)
						value.ForwardingHint[j].Val, err3 = reader.ReadBuf(int(l))
						if err1 != nil || err2 != nil || err3 != nil {
							err = io.ErrUnexpectedEOF
							break
						}
					}
					if err == nil && reader.Pos() != endName {
						err = enc.ErrBufferOverflow
					}

				}
			case 193:
				if progress+1 == 6 {
					handled = true
					if value.Params == nil {
						value.Params = make([]*Param, 0)
					}
					{
						pseudoValue := struct {
							Params *Param
						}{}
						{
							value := &pseudoValue
							value.Params, err = context.Params_context.Parse(reader.Delegate(int(l)), ignoreCritical)
							_ = value
						}
						value.Params = append(value.Params, pseudoValue.Params)
					}
					progress--

				}
			default:
				handled = true
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
				switch progress {
				case 0 - 1:
					err = enc.ErrSkipRequired{Name: "Status", TypeNum: 155}
				case 1 - 1:
					value.ChalStatus = nil
				case 2 - 1:
					value.RemainTries = nil
				case 3 - 1:
					value.RemainTime = nil
				case 4 - 1:
					value.CertName = nil
				case 5 - 1:
					value.ForwardingHint = nil
				case 6 - 1:

				}
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}
	startPos = reader.Pos()
	for ; progress < 7; progress++ {
		switch progress {
		case 0 - 1:
			err = enc.ErrSkipRequired{Name: "Status", TypeNum: 155}
		case 1 - 1:
			value.ChalStatus = nil
		case 2 - 1:
			value.RemainTries = nil
		case 3 - 1:
			value.RemainTime = nil
		case 4 - 1:
			value.CertName = nil
		case 5 - 1:
			value.ForwardingHint = nil
		case 6 - 1:

		}
	}
	if err != nil {
		return nil, err
	}
	return value, nil
}

func (value *ChallengeDataPlain) Encode() enc.Wire {
	encoder := ChallengeDataPlainEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *ChallengeDataPlain) Bytes() []byte {
	return value.Encode().Join()
}

func ParseChallengeDataPlain(reader enc.ParseReader, ignoreCritical bool) (*ChallengeDataPlain, error) {
	context := ChallengeDataPlainParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}
